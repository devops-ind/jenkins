import groovy.json.JsonSlurper

def configFile = readFileFromWorkspace('jobConfig.json')
def jsonSlurper = new JsonSlurper()
def config = jsonSlurper.parseText(configFile)
config.each {
  def GIT_ORG = it.git_org
  def GIT_BRANCH = it.git_branch
  def GIT_REPO = it.project
  def DOCKER_IMAGE = it.docker_image
  def DEPLOY_APPS = it.deploy_apps
  def GIT_TAG = it.git_tag
  def GIT_QA_TAG = it.git_qa_tag
  def GIT_URL = "git.marriott.com"
  def JOB_TYPE = it.job_type
  def JOB = JOB_TYPE+"-"+GIT_REPO
  def URL = "https://"+GIT_URL+"/"+GIT_ORG+"/"+GIT_REPO+".git"
freeStyleJob(JOB){
description("Job Created for "+GIT_REPO)
logRotator{
    numToKeep(10)
}
parameters {
    wHideParameterDefinition {
      name(GIT_REPO)
      defaultValue(GIT_REPO)
      description('The git repo name, this field is hidden so that the dev-ops can only update them')
    }
    stringParam("GIT_ORG", GIT_ORG , "The GIT Organisation/EID under which the repo is present")
    stringParam("GIT_BRANCH", GIT_BRANCH, "The Branch of git from which the docker images should build")
    stringParam("DOCKER_IMAGE", DOCKER_IMAGE, "The name and tag of the image into which the build/target output should be save as")
    stringParam("DEPLOY_APPS", DEPLOY_APPS, "Space separate list of application names which should be re-deployed with this respective build in sequence of deployment. NOTE: This is a hidden filed and to be managed by dev-ops only")
    stringParam("GIT_TAG", GIT_TAG, "Leave this blank, this is for release level build tagging only")
    stringParam("GIT_QA_TAG", GIT_QA_TAG, "Leave this blank, this is for release level build tagging only")
  }
concurrentBuild()
wrappers {
        credentialsBinding {
            usernamePassword('username', 'password', 'NEW MIDO')
        }
    }
scm{
  git{
    remote{
      url(URL)
      credentials('NEW MIDO')
      }
      branch(GIT_BRANCH)
      }
    }
steps {
  managedScript('git-repo-clone'){
    arguments('$GIT_ORG')
    arguments('$GIT_REPO')
    arguments('$GIT_BRANCH')
    arguments('$GIT_TAG')
  }
  conditionalSteps{
    condition{
      not {
        fileExists('.git-no-change', BaseDir.WORKSPACE)
      }
      steps{
        managedScript('run-sbt-only'){
          arguments('clean compile stage')
          arguments('ram')
        }
        managedScript('docker-create-image-and-tag'){
          arguments('$GIT_BRANCH')
          arguments('$DOCKER_IMAGE')
          arguments('$GIT_TAG')
          arguments('$GIT_QA_TAG')
          arguments('$BUILD_NUMBER')
        }
      }
    }
  }
}
}
}
